{"Name":"Firebase Database for iOS","Id":3415,"Alias":"firebaseiosdatabase","Description":"Store and sync data with Firebase NoSQL cloud database. Data is synced across all clients in realtime, and remains available when your app goes offline.\n\nThe Firebase Realtime Database is a cloud-hosted database. Data is stored as JSON and synchronized in realtime to every connected client. When you build cross-platform apps with our iOS, Android, and JavaScript SDKs, all of your clients share one Realtime Database instance and automatically receive updates with the newest data.\n\n## Key capabilities\n\n* **Realtime:** Instead of typical HTTP requests, the Firebase Realtime Database uses data synchronization—every time data changes, any connected device receives that update within milliseconds. Provide collaborative and immersive experiences without thinking about networking code.\n* **Offline:** Firebase apps remain responsive even when offline because the Firebase Realtime Database SDK persists your data to disk. Once connectivity is reestablished, the client device receives any changes it missed, synchronizing it with the current server state.\n* **Accessible from Client Devices:** The Firebase Realtime Database can be accessed directly from a mobile device or web browser; there’s no need for an application server. Security and data validation are available through the Firebase Realtime Database Security Rules, expression-based rules that are executed when data is read or written.\n\n## How does it work?\n\nThe Firebase Realtime Database lets you build rich, collaborative applications by allowing secure access to the database directly from client-side code. Data is persisted locally, and even while offline, realtime events continue to fire, giving the end user a responsive experience. When the device regains connection, the Realtime Database synchronizes the local data changes with the remote updates that occurred while the client was offline, merging any conflicts automatically.\n\nThe Realtime Database provides a flexible, expression-based rules language, called Firebase Realtime Database Security Rules, to define how your data should be structured and when data can be read from or written to. When integrated with Firebase Authentication, developers can define who has access to what data, and how they can access it.\n\nThe Realtime Database is a NoSQL database and as such has different optimizations and functionality compared to a relational database. The Realtime Database API is designed to only allow operations that can be executed quickly. This enables you to build a great realtime experience that can serve millions of users without compromising on responsiveness. Because of this, it is important to think about how users need to access your data and then [structure it accordingly][1].\n\n\u003csub\u003e_Portions of this page are modifications based on work created and [shared by Google](https://developers.google.com/readme/policies/) and used according to terms described in the [Creative Commons 3.0 Attribution License](http://creativecommons.org/licenses/by/3.0/). Click [here](https://firebase.google.com/docs/database/) to see original Firebase documentation._\u003c/sub\u003e\n\n[1]: https://firebase.google.com/docs/database/web/structure-data","Version":"3.1.1.2","Summary":"Store and sync data with the Firebase Realtime Database. Data is synced across all clients in realtime, and remains available when your app goes offline.","QuickStart":"# Firebase Database on iOS\n\nThe Firebase Database is a cloud-hosted database. Data is stored as JSON and synchronized in realtime to every connected client. When you build cross-platform apps with our Android, iOS, and JavaScript SDKs, all of your clients share one Realtime Database instance and automatically receive updates with the newest data.\n\n## Add Firebase to your app\n\n1. Create a Firebase project in the [Firebase console][1], if you don\u0027t already have one. If you already have an existing Google project associated with your mobile app, click **Import Google Project**. Otherwise, click **Create New Project**.\n2. Click **Add Firebase to your iOS app** and follow the setup steps. If you\u0027re importing an existing Google project, this may happen automatically and you can just [download the config file][2].\n3. When prompted, enter your app\u0027s bundle ID. It\u0027s important to enter the bundle ID your app is using; this can only be set when you add an app to your Firebase project.\n4. At the end, you\u0027ll download a `GoogleService-Info.plist` file. You can [download this file][2] again at any time.\n\n## Configure Database in your app\n\nOnce you have your `GoogleService-Info.plist` file downloaded in your computer, do the following steps in Xamarin Studio:\n\n1. Add `GoogleService-Info.plist` file to your app project.\n2. Set `GoogleService-Info.plist` **build action** behaviour to `Bundle Resource` by Right clicking/Build Action.\n3. Add the following line of code somewhere in your app, typically in your AppDelegate\u0027s `FinishedLaunching` method (don\u0027t forget to import `Firebase.Analytics` namespace):\n\n```csharp\nApp.Configure ();\n```\n\n## Structure Your Database\n\nBefore you continue, please, read this [documentation][10] to know how Database is structured and best practices for data structure. \n\n## Recommended documentation to get a better understanding of the Security \u0026 Rules of Firebase Database\n\nBefore you continue, I invite you to read these following docs to make your coding easier:\n\n* [Understand Rules][13]\n* [Get Started][14]\n* [Secure Data][15]\n* [Secure User Data][16]\n* [Index Data][17]\n* [Manage Rules via REST][18]\n\n## Configure Firebase Database Rules\n\nThe Realtime Database provides a declarative rules language that allows you to define how your data should be structured, how it should be indexed, and when your data can be read from and written to. By default, read and write access to your database is restricted so only authenticated users can read or write data. To get started without setting up [Authentication][3], you can [configure your rules for public access][4]. This does make your database open to anyone, even people not using your app, so be sure to restrict your database again when you set up authentication.\n\n## Read and Write Data on iOS\n\nThis document covers the basics of reading and writing Firebase data.\n\nFirebase data is written to a `Database` reference and retrieved by attaching an asynchronous listener to the reference. The listener is triggered once for the initial state of the data and again anytime the data changes.\n\nTo read or write data from the database, you need an instance of `DatabaseReference`:\n\n```csharp\nDatabaseReference rootNode = Database.DefaultInstance.GetRootReference ();\n```\n\nDoing this, you will have a variable called `rootNode` that points to **https://yourFirebaseDatabase/**\n\n### Basic write operations\n\nFor basic write operations, you can use `SetValue\u003cT\u003e (T value)`, `SetValues\u003cT\u003e (T [] values)` or `SetValues (NSObject [] values)` to save data to a specified reference, replacing any existing data at that path. You can use this method to pass types that correspond to the available JSON types as follows:\n\n* NSString\n* NSNumber\n* NSDictionary\n* NSArray\n\n***Note:*** *If you pass an object different from these 4 types, an exception will be thrown. Types inherited from these 4 types will be accepted.*\n\nFor instance, you can add a user with `SetValue\u003cT\u003e (T value)`. First create a reference that points to the user reference:\n\n```csharp\nDatabaseReference userNode = rootNode.GetChild (\"users\").GetChild (user.Uid);\n```\n\nDoing this, now you have a variable that points to **https://yourFirebaseDatabase/users/$userUid** where **$userUid** is the key of the reference. The reference is created even if it doesn\u0027t exist but only will be saved into Firebase Database until you assign some value to the reference:\n\n```csharp\nobject [] keys = { \"username\" };\nobject [] values = { username };\nvar data = NSDictionary.FromObjectsAndKeys (values, keys, keys.Length);\n\nuserNode.SetValue\u003cNSDictionary\u003e (data);\n```\n\nYou can avoid creating variables for each reference and assign the value directly:\n\n```csharp\nrootNode.GetChild (\"users\").GetChild (user.Uid).SetValue\u003cNSDictionary\u003e (data);\n```\n\nUsing `SetValue` in these ways overwrites data at the specified location, including any child nodes. However, you can still update a child without rewriting the entire object. If you want to allow users to update their profiles you could update the username as follows:\n\n```csharp\nrootNode.GetChild (\"users\").GetChild (user.Uid).GetChild (\"username\").SetValue\u003cNSString\u003e (username);\n```\n\n### Listen for value events\n\nTo read data at a path and listen for changes, use the `ObserveEvent` or `ObserveSingleEvent` methods of `DatabaseReference` to observe `DataEventType.Value` events.\n\n| Event type              | Typical usage                                                 |\n|:-----------------------:|---------------------------------------------------------------|\n| **DataEventType.Value** | Read and listen for changes to the entire contents of a path. |\n\nYou can use the `DataEventType.Value` event to read the data at a given path, as it exists at the time of the event. This method is triggered once when the listener is attached and again every time the data, including any children, changes. The event callback is passed a `snapshot` containing all data at that location, including child data. If there is no data, the `value` of the `snapshot` returned is `null`.\n\n***Important:*** *The `DataEventType.Value` event is fired every time data is changed at the specified database reference, including changes to children. To limit the size of your snapshots, attach only at the highest level needed for watching changes. For example, attaching a listener to the root of your database is not recommended.*\n\nThe following example demonstrates a notes application retrieving the user\u0027s folders from the database:\n\n```csharp\nDatabaseReference foldersNode = rootNode.GetChild (\"folders\").GetChild (user.Uid);\nnuint handleReference = foldersNode.ObserveEvent (DataEventType.Value, (snapshot) =\u003e {\n\tvar folderData = snapshot.GetValue\u003cNSDictionary\u003e ();\n\t// Do magic with the folder data\n});\n```\n\nThe listener receives a `DataSnapshot` that contains the data at the specified location in the database at the time of the event in its `GetValue`, `GetValue\u003cT\u003e`, `GetValues` or `GetValues\u003cT\u003e` methods. You can assign the values to the appropriate native type, such as `NSDictionary`. If no data exists at the location, the value is `null`.\n\n### Read data once\n\nIn some cases you may want a callback to be called once and then immediately removed, such as when initializing a UI element that you don\u0027t expect to change. You can use the `ObserveSingleEvent` method to simplify this scenario: the event callback added triggers once and then does not trigger again.\n\nThis is useful for data that only needs to be loaded once and isn\u0027t expected to change frequently or require active listening. For instance, we can use this method to know the total of notes that a folder has:\n\n```csharp\nnuint notesCount;\nDatabaseReference notesCountNode = rootNode.GetChild (\"folders\").GetChild (user.Uid).GetChild (folderUid).GetChild (\"notesCount\");\nnotesCountNode.ObserveSingleEvent (DataEventType.Value, (snapshot) =\u003e {\n\tnotesCount = snapshot.GetValue\u003cNSNumber\u003e ().NUIntValue;\n}, (error) =\u003e {\n\tConsole.WriteLine (error.LocalizedDescription);\n});\n```\n\n### Update specific fields\n\nTo simultaneously write to specific children of a node without overwriting other child nodes, use the `UpdateChildValues` method.\n\nWhen calling updateChildValues, you can update lower-level child values by specifying a path for the key. If data is stored in multiple locations to scale better, you can update all instances of that data using [data fan-out][5]. For example, in notes app, the user wants to save a new note and simultaneously update the total of notes that the folder has. To do this, the code could be like this:\n\n```csharp\nvar noteUid = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid).GetChildByAutoId ().Key;\n\nobject [] noteKeys = { \"content\", \"created\", \"lastModified\", \"title\" };\nobject [] noteValues = { content, created, lastModified, title };\nvar noteData = NSDictionary.FromObjectsAndKeys (noteValues, noteKeys, noteKeys.Length);\n\nobject [] nodes = { $\"notes/{user.Uid}/{folderUid}/{noteUid}\", $\"folders/{user.Uid}/{folderUid}/notesCount\" };\nobject [] nodesValues = { noteData, NSNumber.FromNUInt (++notesCount) };\nvar childUpdates = NSDictionary.FromObjectsAndKeys (nodesValues, nodes, nodes.Length);\n\nrootNode.UpdateChildValues (childUpdates);\n```\n\nUsing these paths, you can perform simultaneous updates to multiple locations in the JSON tree with a single call to `UpdateChildValues` method. Simultaneous updates made this way are atomic: either all updates succeed or all updates fail.\n\n### Delete data\n\nThe simplest way to delete data is to call `RemoveValue` method on a reference to the location of that data.\n\nYou can also delete by specifying `null` as the value for another write operation such as `SetValue\u003cT\u003e` or `UpdateChildValues`. You can use this technique with `UpdateChildValues` to delete multiple children in a single API call:\n\n```csharp\nDatabaseReference noteNode = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid).GetChild (noteUid);\n\n// Same functionality\nnoteNode.RemoveValue ();\nnoteNode.SetValue\u003cNSObject\u003e (null);\n\nobject [] nodes = { $\"notes/{user.Uid}/{folderUid}/{noteUid}\" };\nobject [] nodesValues = { null };\nvar childUpdates = NSDictionary.FromObjectsAndKeys (nodesValues, nodes, nodes.Length);\nrootNode.UpdateChildValues (childUpdates);\n```\n\n## Detach listeners\n\nObservers don\u0027t automatically stop syncing data when you leave a ViewController. If an observer isn\u0027t properly removed, it continues to sync data to local memory. When an observer is no longer needed, remove it by passing the associated **DatabaseHandle** to the `RemoveObserver` method:\n\n```csharp\nDatabaseReference foldersNode = rootNode.GetChild (\"folders\").GetChild (user.Uid);\nnuint handleReference = foldersNode.ObserveEvent (DataEventType.Value, (snapshot) =\u003e {\n\tvar folderData = snapshot.GetValue\u003cNSDictionary\u003e ();\n\t// Do magic with the folder data\n});\n\n// Some other code\n\n// When you don\u0027t want to keep listening for changes in that node, do the following at some point of your app\nfoldersNode.RemoveObserver (handleReference);\n```\n\nWhen you add a callback block to a reference, a `nuint` is returned. These handles can be used to remove the callback block.\n\nIf multiple listeners have been added to a database reference, each listener is called when an event is raised. In order to stop syncing data at that location, you must remove all observers at a location by calling the `RemoveAllObservers` method.\n\nCalling `RemoveObserver` or `RemoveAllObservers` on a listener does not automatically remove listeners registered on its child nodes; you must also be keep track of those references or handles to remove them.\n\n## Save data as transactions\n\nWhen working with data that could be corrupted by concurrent modifications, such as incremental counters, you can use a [transaction operation][6]. You give this operation two arguments: an update function and an optional completion callback. The update function takes the current state of the data as an argument and returns the new desired state you would like to write.\n\nFor instance, imagine that you have a collaborative notes app, and some users are working in the same note, you could allow users to update the note as follows:\n\n```csharp\nnoteNode.RunTransaction ((currentData) =\u003e {\n\tvar noteData = currentData.GetValue\u003cNSDictionary\u003e ();\n\n\tif (noteData == null)\n\t\treturn TransactionResult.Success (currentData);\n\n\tvar mutableNoteData = noteData.MutableCopy () as NSMutableDictionary;\n\tmutableNoteData [\"content\"] = content;\n\tmutableNoteData [\"title\"] = title;\n\n\tcurrentData.SetValue\u003cNSMutableDictionary\u003e (mutableNoteData);\n\n\treturn TransactionResult.Success (currentData);\n}, (error, commited, snapshot) =\u003e {\n\tif (error != null) {\n\t\tConsole.WriteLine (error.LocalizedDescription);\n\t}\n});\n```\n\nUsing a transaction prevents note content from being incorrect if multiple users edit the same note at the same time or the client had stale data. The value contained in the `MutableData` class is initially the client\u0027s last known value for the path, or `null` if there is none. The server compares the initial value against it\u0027s current value and accepts the transaction if the values match, or rejects it. If the transaction is rejected, the server returns the current value to the client, which runs the transaction again with the updated value. This repeats until the transaction is accepted or too many attempts have been made.\n\n***Note:*** *Because `RunTransaction` method is called multiple times, it must be able to handle `null` data. Even if there is existing data in your remote database, it may not be locally cached when the transaction function is run, resulting in `null` for the initial value.*\n\n## Write data offline\n\nIf a client loses its network connection, your app will continue functioning correctly.\n\nEvery client connected to a Firebase database maintains its own internal version of any active data. When data is written, it\u0027s written to this local version first. The Firebase client then synchronizes that data with the remote database servers and with other clients on a \"best-effort\" basis.\n\nAs a result, all writes to the database trigger local events immediately, before any data is written to the server. This means your app remains responsive regardless of network latency or connectivity.\n\nOnce connectivity is reestablished, your app receives the appropriate set of events so that the client syncs with the current server state, without having to write any custom code.\n\n## Work with Lists of Data on iOS\n\n### Append to a list of data\n\nUse the `GetChildByAutoId` method to append data to a list in multiuser applications. The `GetChildByAutoId` method generates a unique key every time a new child is added to the specified Firebase reference. By using these auto-generated keys for each new element in the list, several clients can add children to the same location at the same time without write conflicts. The unique key generated by `GetChildByAutoId` is based on a timestamp, so list items are automatically ordered chronologically.\n\nYou can use the reference to the new data returned by the `GetChildByAutoId` method to get the value of the child\u0027s auto-generated key or set data for the child. Calling `Key` property on a `GetChildByAutoId` reference returns the auto-generated key.\n\nYou can use these auto-generated keys to simplify flattening your data structure. For more information, see the data fan-out [example][5].\n\n### Listen for child events\n\nChild events are triggered in response to specific operations that happen to the children of a node from an operation such as a new child added through the `GetChildByAutoId` method or a child being updated through the `UpdateChildValues` method.\n\n| Event type                     | Typical usage |\n|:------------------------------:|---------------|\n| **DataEventType.ChildAdded**   | Retrieve lists of items or listen for additions to a list of items. This event is triggered once for each existing child and then again every time a new child is added to the specified path. The listener is passed a snapshot containing the new child\u0027s data. Also, It is used with data that is ordered by `GetQueryOrderedByChild` or `GetQueryOrderedByValue` methods. |\n| **DataEventType.ChildChanged** | Listen for changes to the items in a list. This event is triggered any time a child node is modified. This includes any modifications to descendants of the child node. The snapshot passed to the event listener contains the updated data for the child. |\n| **DataEventType.ChildRemoved** | Listen for items being removed from a list. This event is triggered when an immediate child is removed.The snapshot passed to the callback block contains the data for the removed child. |\n| **DataEventType.ChildMoved**   | Listen for changes to the order of items in an ordered list. This event is triggered whenever an update causes reordering of the child. |\n\nEach of these together can be useful for listening to changes to a specific node in a database. For example, the notes app could use these methods together to monitor activity when a folder is created or deleted, as shown below:\n\n```csharp\n// Listen for new folders in the Firebase database\nfoldersNode.ObserveEvent (DataEventType.ChildAdded, (snapshot, prevKey) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar name = data [\"name\"].ToString ();\n\tvar notesCount = (data [\"notesCount\"] as NSNumber).UInt32Value;\n\t\n\tvar folder = new Folder {\n\t\tName = name,\n\t\tCreated = created,\n\t\tLastModified = AppDelegate.ConvertUnformattedUtcDateToCurrentDate (lastModified),\n\t\tNotesCount = notesCount\n\t};\n\t\n\tfolders.Add (folder);\n\n\tTableView.ReloadData ();\n});\n\n// Listen for deleted comments in the Firebase database\nfoldersNode.ObserveEvent (DataEventType.ChildRemoved, (snapshot, prevKey) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar name = data [\"name\"].ToString ();\n\tvar notesCount = (data [\"notesCount\"] as NSNumber).UInt32Value;\n\t\n\tvar folder = new Folder {\n\t\tName = name,\n\t\tCreated = created,\n\t\tLastModified = AppDelegate.ConvertUnformattedUtcDateToCurrentDate (lastModified),\n\t\tNotesCount = notesCount\n\t};\n\t\n\tfolders.Remove (folder);\n\n\tTableView.ReloadData ();\n});\n```\n\n### Listen for value events\n\nWhile listening for child events is the recommended way to read lists of data, there are situations listening for value events on a list reference is useful.\n\nAttaching a `DataEventType.Value` observer to a list of data will return the entire list of data as a single DataSnapshot, which you can then loop over to access individual children.\n\nEven when there is only a single match for the query, the snapshot is still a list; it just contains a single item. To access the item, you need to loop over the result:\n\n```csharp\nfoldersNode.ObserveEvent (DataEventType.Value, (snapshot) =\u003e {\n\t// Loop over the children\n\tNSEnumerator children = snapshot.Children;\n\tvar child = children.NextObject () as DataSnapshot;\n\n\twhile (child != null) {\n\t\t// Work with data...\n\n\t\tchild = children.NextObject () as DataSnapshot;\n\t}\n});\n```\n\nThis pattern can be useful when you want to fetch all children of a list in a single operation, rather than listening for additional child added events.\n\n## Sorting and filtering data\n\nYou can use the Realtime Database `DatabaseQuery` class to retrieve data sorted by key, by value, or by the value of a child. You can also filter the sorted result to a specific number of results or a range of keys or values.\n\n***Note:*** *Filtering and sorting can be expensive, especially when done on the client. If your app uses queries, define the .indexOn rule to index those keys on the server and improve query performance as described in [Indexing Your Data][7].*\n\n### Sort data\n\nTo retrieve sorted data, start by specifying one of the order-by methods to determine how results are ordered:\n\n| Method                     | Usage                                                |\n|:--------------------------:|------------------------------------------------------|\n| **GetQueryOrderedByKey**   | Order results by child keys.                         |\n| **GetQueryOrderedByValue** | Order results by child values.                       |\n| **GetQueryOrderedByChild** | Order results by the value of a specified child key. |\n\nYou can only use **one** order-by method at a time. Calling an order-by method multiple times in the same query **throws an error**.\n\nThe following example demonstrates how you could retrieve a list of a notes sorted by their last time modified:\n\n```csharp\nDatabaseReference notesNode = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid);\n\n// Get all notes sorted by their last time modified in ascending order\nDatabaseQuery notesByDate = notesNode.GetQueryOrderedByChild (\"lastModified\");\nnotesByDate.ObserveEvent (DataEventType.ChildAdded, (snapshot) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar content = data [\"content\"].ToString ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar title = data [\"title\"].ToString ();\n\t\n\tvar note = new Note {\n\t\tContent = content,\n\t\tCreated = created,\n\t\tLastModified = lastModified,\n\t\tTitle = title\n\t}\n\t\n\tnotes.Add (note);\n\n\tTableView.ReloadData ();\n});\n```\n\nThis query retrieves the user\u0027s notes from the path in the database based on their user Id and the folder Id, ordered by the last time modified. This technique of using IDs as index keys is called data fan out, you can read more about it in [Structure Your Database][5].\n\nThe call to the `GetQueryOrderedByChild` method specifies the child key to order the results by. In this case, notes are sorted by the value of the **lastModified** child in each post. For more information on how other data types are ordered, see [How query data is ordered][8].\n\n### Filtering data\n\nTo filter data, you can combine any of the limit or range methods with an order-by method when constructing a query.\n\n| Method                      | Usage                                                                                                      |\n|:---------------------------:|------------------------------------------------------------------------------------------------------------|\n| **GetQueryLimitedToFirst**  | Sets the maximum number of items to return from the beginning of the ordered list of results.              |\n| **GetQueryLimitedToLast**   | Sets the maximum number of items to return from the end of the ordered list of results.                    |\n| **GetQueryStartingAtValue** | Return items greater than or equal to the specified key or value, depending on the order-by method chosen. |\n| **GetQueryEndingAtValue**   | Return items less than or equal to the specified key or value, depending on the order-by method chosen.    |\n| **GetQueryEqualToValue**    | Return items equal to the specified key or value, depending on the order-by method chosen.                 |\n\nUnlike the order-by methods, you can combine multiple limit or range functions. For example, you can combine the `GetQueryStartingAtValue` and `GetQueryEndingAtValue` methods to limit the results to a specified range of values.\n\n### Limit the number of results\n\nYou can use the `GetQueryLimitedToFirst` and `GetQueryLimitedToLast` methods to set a maximum number of children to be synced for a given callback. For example, if you use `GetQueryLimitedToFirst` to set a limit of 100, you initially only receive up to 100 `DataEventType.ChildAdded` callbacks. If you have fewer than 100 items stored in your Firebase database, an `DataEventType.ChildAdded` callback fires for each item.\n\nAs items change, you receive `DataEventType.ChildAdded` callbacks for items that enter the query and `DataEventType.ChildRemoved` callbacks for items that drop out of it so that the total number stays at 100.\n\nThe following example demonstrates how example notes app retrieves a list of the 100 most recent modified notes by user:\n\n```csharp\nDatabaseReference notesNode = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid);\n\n// First 100 notes sorted by their last time modified in ascending order\nDatabaseQuery notesByDate = notesNode.GetQueryOrderedByChild (\"lastModified\").GetQueryLimitedToFirst (100);\nnotesByDate.ObserveEvent (DataEventType.ChildAdded, (snapshot) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar content = data [\"content\"].ToString ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar title = data [\"title\"].ToString ();\n\t\n\tvar note = new Note {\n\t\tContent = content,\n\t\tCreated = created,\n\t\tLastModified = lastModified,\n\t\tTitle = title\n\t}\n\t\n\tnotes.Add (note);\n\n\tTableView.ReloadData ();\n});\n```\n\n### Filter by key or value\n\nYou can use `GetQueryStartingAtValue`, `GetQueryEndingAtValue`, and `GetQueryEqualToValue` to choose arbitrary starting, ending, and equivalence points for queries. This can be useful for paginating data or finding items with children that have a specific value.\n\n## How query data is ordered\n\nThis section explains how data is sorted by each of the order-by methods in the `DatabaseQuery` class.\n\n### GetQueryOrderedByKey method\n\nWhen using `GetQueryOrderedByKey` to sort your data, data is returned in ascending order by key.\n\n1. Children with a key that can be parsed as a 32-bit integer come first, sorted in ascending order.\n2. Children with a string value as their key come next, sorted [lexicographically][9] in ascending order.\n\n### GetQueryOrderedByValue method\n\nWhen using `GetQueryOrderedByValue`, children are ordered by their value. The ordering criteria are the same as in `GetQueryOrderedByChild`, except the value of the node is used instead of the value of a specified child key.\n\n### GetQueryOrderedByChild method\n\nWhen using `GetQueryOrderedByChild`, data that contains the specified child key is ordered as follows:\n\n1. Children with a `null` value for the specified child key come first.\n2. Children with a value of `false` for the specified child key come next. If multiple children have a value of false, they are sorted [lexicographically][9] by key.\n3. Children with a value of `true` for the specified child key come next. If multiple children have a value of true, they are sorted lexicographically by key.\n4. Children with a numeric value come next, sorted in ascending order. If multiple children have the same numerical value for the specified child node, they are sorted by key.\n5. Strings come after numbers and are sorted lexicographically in ascending order. If multiple children have the same value for the specified child node, they are ordered lexicographically by key.\n6. Objects come last and are sorted lexicographically by key in ascending order.\n\n## Offline Capabilities on iOS\n\nFirebase apps work great offline and we have several features to make the experience even better. Enabling disk persistence allows your app to keep all of its state even after an app restart. We provide several tools for monitoring presence and connectivity state.\n\n### Disk Persistence\n\nFirebase apps automatically handle temporary network interruptions for you. Cached data will still be available while offline and your writes will be resent when network connectivity is recovered. Enabling disk persistence allows our app to also keep all of its state even after an app restart. We can enable disk persistence with just one line of code:\n\n```csharp\nDatabase.DefaultInstance.PersistenceEnabled = true;\n```\n\nWith disk persistence enabled, our synced data and writes will be persisted to disk across app restarts and our app should work seamlessly in offline situations.\n\n### Persistence Behavior\n\nBy enabling persistence, any data that we sync while online will be persisted to disk and available offline, even when we restart the app. This means our app will work as it would online using the local data stored in the cache. Listener callbacks will continue to fire for local updates.\n\nThe Firebase Database client automatically keeps a queue of all write operations that are performed while our application is offline. When persistence is enabled, this queue will also be persisted to disk so all of our writes will be available when we restart the app. When the app regains connectivity, all of the operations will be sent to the server.\n\nIf our app uses [Firebase Authentication][3], the client will persist the user\u0027s authentication token across restarts. If the auth token expires while our app is offline, the client will pause our write operations until we re-authenticate, else our writes might fail due to security rules.\n\n### Keeping Data Fresh\n\nThe Firebase Database synchronizes and stores a local copy of the data for active listeners. In addition, you can keep specific locations in sync:\n\n```csharp\nDatabaseReference foldersNode = rootNode.GetChild (\"folders\").GetChild (AppDelegate.UserUid);\nfoldersNode.KeepSynced (true);\n```\n\nThe client will automatically download the data at these locations and keep it in sync even if the reference has no active listeners. You can turn synchronization back off with the following line of code:\n\n```csharp\nfoldersNode.KeepSynced (false);\n```\n\nBy default, 10MB of previously synced data will be cached. This should be enough for most applications. If the cache outgrows its configured size, the Firebase Database will purge data that has been used least recently. Data that is kept in sync, will not be purged from the cache.\n\n### Querying Data Offline\n\nThe Firebase Database stores data returned from a query for use when offline. For queries constructed while offline, the Firebase Database continues to work for previously loaded data. If the requested data hasn\u0027t loaded, the Firebase Database loads data from the local cache. When we come back online our data will load and reflect the query.\n\nFor example, here we have a piece of code that queries for the last four items in our Firebase Database of notes:\n\n```csharp\nDatabaseReference notesNode = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid);\n\n// Last 4 notes sorted by their last time modified\nDatabaseQuery notesByDate = notesNode.GetQueryOrderedByChild (\"lastModified\").GetQueryLimitedToLast (4);\nnotesByDate.ObserveEvent (DataEventType.ChildAdded, (snapshot) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar content = data [\"content\"].ToString ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar title = data [\"title\"].ToString ();\n\t\n\tvar note = new Note {\n\t\tContent = content,\n\t\tCreated = created,\n\t\tLastModified = lastModified,\n\t\tTitle = title\n\t}\n\t\n\tnotes.Add (note);\n\n\tTableView.ReloadData ();\n});\n```\n\nNow let\u0027s assume that the user loses connection, goes offline, and restarts the app. While still offline, we query for the last two items from the same location. This query will successfully return the last two items because we had loaded all four in the query above:\n\n```csharp\nDatabaseReference notesNode = rootNode.GetChild (\"notes\").GetChild (user.Uid).GetChild (folderUid);\n\n// Last 2 notes sorted by their last time modified\nDatabaseQuery notesByDate = notesNode.GetQueryOrderedByChild (\"lastModified\").GetQueryLimitedToLast (2);\nnotesByDate.ObserveEvent (DataEventType.ChildAdded, (snapshot) =\u003e {\n\tvar data = snapshot.GetValue\u003cNSDictionary\u003e ();\n\tvar content = data [\"content\"].ToString ();\n\tvar created = data [\"created\"].ToString ();\n\tvar lastModified = data [\"lastModified\"].ToString ();\n\tvar title = data [\"title\"].ToString ();\n\t\n\tvar note = new Note {\n\t\tContent = content,\n\t\tCreated = created,\n\t\tLastModified = lastModified,\n\t\tTitle = title\n\t}\n\t\n\tnotes.Add (note);\n\n\tTableView.ReloadData ();\n});\n```\n\nIn the above example, the Firebase Database client raises `DataEventType.ChildAdded` events for the latest modified notes, via our persisted cache. But it will not raise a `DataEventType.Value` event, since we\u0027ve never done that query while online.\n\nIf we were to request the last six items while offline, we\u0027d get `DataEventType.ChildAdded` events for the four cached items straight away. When we come back online, the Firebase Realtime Database client will synchronize with the server and we\u0027ll get the final two `DataEventType.ChildAdded` and the `DataEventType.Value` events.\n\n### Handling Transactions Offline\n\nAny transactions that are performed while our app is offline, will be queued. Once the app regains network connectivity, the transactions will be sent to the server.\n\nIt\u0027s important to know that **Transactions are not persisted across app restarts**. Even with persistence enabled, transactions are not persisted across app restarts. So you cannot rely on transactions done offline being committed to your Firebase Database. To provide the best user experience, your app should show that a transaction has not been saved into your Firebase Database yet, or make sure your app remembers them manually and executes them again after an app restart.\n\n## Managing Presence\n\nIn realtime applications it is often useful to detect when clients connect and disconnect. For example, we may want to mark a user as \u0027offline\u0027 when their client disconnects.\n\nFirebase Database clients provide simple primitives that allow data to be written to the database when a client disconnects from the Firebase Database servers. These updates will occur whether the client disconnects cleanly or not, so we can rely on them to clean up data even if a connection is dropped or a client crashes. All write operations, including setting, updating, and removing, can be performed upon a disconnection.\n\nHere is a simple example of writing data upon disconnection by using the **OnDisconnect** primitive:\n\n```csharp\nDatabaseReference disconnectedNode = rootNode.GetChild (\"disconnected\");\n// Write a string when this client loses connection\ndisconnectedNode.SetValueOnDisconnect\u003cNSString\u003e (new NSString (\"I disconnected!\"));\n```\n\n### How OnDisconnect methods works\n\nWhen an **OnDisconnect** operation is established, it lives on the Firebase Database server. The server checks security to make sure the user can perform the write event requested, and informs the client if it is invalid. The server then monitors the connection. If at any point it times out, or is actively closed by the client, the server checks security a second time (to make sure the operation is still valid) and then invokes the event.\n\nThe client can use the callback on the write operation to ensure the **OnDisconnect** was correctly attached:\n\n```csharp\nrootNode.RemoveValueOnDisconnect ((error, reference) =\u003e {\n\tif (error != null) {\n\t\tConsole.WriteLine ($\"Could not establish onDisconnect event: {error.LocalizedDescription}\");\n\t}\n});\n```\n\nAn **OnDisconnect** event can also be canceled by calling `CancelDisconnectOperations` method:\n\n```csharp\nrootNode.CancelDisconnectOperations ();\n```\n\n## Detecting Connection State\n\nFor many presence-related features, it is useful for a client to know when it is online or offline. Firebase Database clients provide a special location at **/.info/connected** which is updated every time the client\u0027s connection state changes. Here is an example:\n\n```csharp\nDatabaseReference connectedNode = Database.DefaultInstance.GetReferenceFromPath (\".info/connected\");\nconnectedNode.ObserveEvent (DataEventType.Value, (snapshot) =\u003e {\n\tvar connected = snapshot.GetValue\u003cNSNumber\u003e ().BoolValue;\n\n\tif (connected)\n\t\tConsole.WriteLine (\"Connected\");\n\telse \n\t\tConsole.WriteLine (\"Not connected\");\n});\n```\n\n**/.info/connected** is a boolean value which is not synchronized between clients because the value is dependent on the state of the client. In other words, if one client reads **/.info/connected** as `false`, this is no guarantee that a separate client will also read `false`.\n\n## Handling Latency\n\n### Server Timestamps\n\nThe Firebase Database servers provide a mechanism to insert timestamps generated on the server as data. This feature, combined with **OnDisconnect**, provides an easy way to reliably make note of the time at which a client disconnected:\n\n```csharp\nDatabaseReference userLastOnlineNode = Database.DefaultInstance.GetReferenceFromPath ($\"users/{user.Uid}/lastOnline\");\nuserLastOnlineNode.SetValueOnDisconnect\u003cNSDictionary\u003e (ServerValue.Timestamp);\n```\n\n### Clock Skew\n\nWhile `ServerValue.Timestamp` is much more accurate, and preferable for most read/write ops, it can occasionally be useful to estimate the clients clock skew with respect to the Firebase Database\u0027s servers. We can attach a callback to the location **/.info/serverTimeOffset** to obtain the value, in milliseconds, that Firebase Database clients will add to the local reported time (epoch time in milliseconds) to estimate the server time. Note that this offset\u0027s accuracy can be affected by networking latency, and so is useful primarily for discovering large (\u003e 1 second) discrepancies in clock time:\n\n```csharp\nDatabaseReference offsetNode = Database.DefaultInstance.GetReferenceFromPath (\".info/serverTimeOffset\");\noffsetNode.ObserveSingleEvent (DataEventType.Value, (snapshot) =\u003e {\n\tvar offset = snapshot.GetValue\u003cNSNumber\u003e ().DoubleValue;\n\n\tvar ticksFrom1970 = new System.DateTime (1970, 1, 1, 0, 0, 0, 0).Ticks;\n\tvar ticksUtc = System.DateTime.UtcNow.Ticks;\n\tvar epoch = (ticksUtc - ticksFrom1970) / System.TimeSpan.TicksPerMillisecond;\n\n\tvar estimatedServerTimeMs = epoch + offset;\n});\n```\n\n## Best practices\n\nTo learn about Firebase Database best practices, please visit this [Firebase post][11].\n\n### Known issues\n\n* App doesn\u0027t compile when `Incremental builds` is enabled. (Bug [#43689][12])\n\n\u003csub\u003e_Portions of this page are modifications based on work created and [shared by Google](https://developers.google.com/readme/policies/) and used according to terms described in the [Creative Commons 3.0 Attribution License](http://creativecommons.org/licenses/by/3.0/). Click [here](https://firebase.google.com/docs/database/ios/start) to see original Firebase documentation._\u003c/sub\u003e\n\n[1]: https://firebase.google.com/console/\n[2]: http://support.google.com/firebase/answer/7015592\n[3]: https://components.xamarin.com/view/firebaseiosanalytics\n[4]: https://firebase.google.com/docs/database/security/quickstart#sample-rules\n[5]: https://firebase.google.com/docs/database/ios/structure-data#fanout\n[6]: https://firebase.google.com/docs/reference/ios/firebasedatabase/interface_f_i_r_database_reference.html#a796bff455159479a44b225eeaa2ba9d6\n[7]: https://firebase.google.com/docs/database/security/indexing-data\n[8]: https://firebase.google.com/docs/database/ios/lists-of-data#data_order\n[9]: http://en.wikipedia.org/wiki/Lexicographical_order\n[10]: https://firebase.google.com/docs/database/ios/structure-data\n[11]: https://firebase.googleblog.com/2015/10/best-practices-for-ios-uiviewcontroller_6.html\n[12]: https://bugzilla.xamarin.com/show_bug.cgi?id=43689\n[13]: https://firebase.google.com/docs/database/security/\n[14]: https://firebase.google.com/docs/database/security/quickstart\n[15]: https://firebase.google.com/docs/database/security/securing-data\n[16]: https://firebase.google.com/docs/database/security/user-security\n[17]: https://firebase.google.com/docs/database/security/indexing-data\n[18]: https://firebase.google.com/docs/database/rest/app-management\n","Hash":"3efec8f646a6bcb11044a55e7e39997f","TargetPlatforms":["ios","ios-unified"],"TrialHash":null}